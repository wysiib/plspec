\documentclass{article}
\usepackage{hyperref}
\usepackage{breakurl}

\usepackage[english]{babel}
\usepackage[autostyle=true]{csquotes}

%\usepackage{latexsym}
\usepackage{amsthm,amssymb}
\usepackage{mathtools}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{listingsutf8}

\usepackage{booktabs}

\usepackage{tikz}
\usetikzlibrary{shapes.multipart}

\usepackage[boxed,noline]{algorithm2e}
% \dontprintsemicolon was renamed in later versions of algorithm2e
% if the new command \DontPrintSemicolon does not exist, we replace it by the old one
% this should provide compatibility with older versions
\providecommand{\DontPrintSemicolon}{\dontprintsemicolon}
\SetAlCapSkip{\abovecaptionskip}
\SetAlCapSty{}

\usepackage{hyperref}
\usepackage[capitalise]{cleveref}

\newcommand{\ignore}[1]{} % {{\tt \small ignore(#1)}}



\title{asdfgsd}

\begin{document}
\maketitle

\begin{abstract}
TODO
\end{abstract}

\section{Overview}

Consider following example:

\begin{verbatim}
my_member(E, [E|_]).
my_member(E, [_|T]) :-
    my_member(E, T).
\end{verbatim}

\emph{plspec} offers the following descriptions for predicates.
The first argument always refers to the predicate that the spec is written for,
e.g. \verb|my_member/2|.

\begin{itemize}
    \item
        At least one instance of \verb|spec_pre/2|,
        where the second argument describes a valid call of the predicate.
        If the first argument to \verb|my_member/2| can be anything,
        but the second one should be a list (and not a variable),
        it would be \verb|spec_pre(my_member/2, [any, [any]])|.

    \item
        Optionally an instance of \verb|spec_invariant/2|.
        When variables are bound,
        they must still unify with an instance the second argument describes.
        If a spec for \verb|my_member/2| was
        \verb|spec_invariant(member/2, [any, atom])|,
        then it would fail since the first clause
        binds the second argument to a list (of variables).
        Additionally, partial instantiation of variables is supported.
        Consider the spec \verb|[int]|, i.e. a list of integers.
        A variable \verb|_| is valid for this spec.
        When it is bound to, for instance, to a list of variables,
        e.g. \verb|[_, _]|, this value is still valid.
        The lists \verb|[_, 2]|, \verb|[1, _]| as well as \verb|[1, 2]|
        remain valid since they can be unified such that a ground term matches the spec.
        However, \verb|[a, _]| is not valid.

    \item
        Any amount of instances of \verb|spec_post/3|.
        Its second argument describes a spec
        that may or may not be matched when calling the predicate.
        If it was matched, however, the spec contained in the third argument
        has to match after the predicate succeeded (if it succeeds at all).

\end{itemize}

\section{Define Your Own Specs}

Most specs are implemented as you would implement your own spec.
Basic building blocks are created via \verb|defspec_pred/2|.
The first argument is the name you give to your spec,
whereas the second argument is the predicate
that should be called in order to check the value.

As an example, we might want to check whether values are floating point numbers.
We could implement it via \verb|defspec_pred(floating_point, float)|.
When the spec \verb|floating_point| is encounted for a value \verb|V|,
the predicate \verb|float(V)| is called.

%% TODO: even integers as an example?

Furthermore, we allow aliasing via \verb|defspec|.
Internally, the spec \verb|int| is an alias for the spec \verb|integer|.
More complex and recursives specs are supported as well.

%% TODO: trees as an example?

Lastly, the most complicated type of specs are
definitions which depend on one or more other specs,
e.g. \verb|list(int)|.
In order to allow checks for invariant,
only a small aspect should be checked by a predicate,
in this example that the value is indeed a list.
\verb|list(X)| is implemented via \verb|defspec_recursive/2|.
The associated predicate takes for arguments:
firstly, the argument \verb|X| of \verb|list(X)| itself;
secondly, the actual value.
The third argument is a variable that should be bound to a list
of specifications that still have to be checked on
a list of values which is returned in the fourth argument.




%\bibliographystyle{eptcs}
%\bibliography{plspec}

\end{document}
